---
title: "[IOS] WWDC 2018 High Performance Auto Layout"
layout: post
hidden: true
date: 2019-04-06 02:22
tag:
- WWDC
- IOS
- AutoLayout
- 오토레이아웃
star: true
category: blog
author: jhyejun
description: wwdc 2018 high performance auto layout
---

## WWDC 2018 High Performance Auto Layout 내용 정리

###


#### 잘못된 부분에 대한 피드백은 언제나 작성자에게 힘과 도움이 됩니다.

이전에 2011년도에 오토레이아웃을 소개할 때 발표했던 사람이 다시 와서 발표하기 시작함
오늘 이렇게 다시 만나서 얘기하게 되어 기쁘다고 함.

오토레이아웃이란
iOS나 Mac에서의 콘텐츠를 어느 위치에 놓을지 정하는 것
메인 오브젝트와 뷰, 컨스트레인트로 이루어져있다.
컨스트레인트는 뷰 사이의 관계를 정의해준다.

그냥 단순히 오토레이아웃으로 버튼과의 거리가 20으로 설정만 한다면 이것이 어떤 과정을 통해서 적용되는지 이해하기 어려울 수 있고, 그로 인해 성능에 대한 기대치를 이해하고 어떤 것이 빠르고 어떤 것이 좋은 것인지 이해하기 어려울 수 있다.

그래서 이번 강연의 목표는 오토레이아웃이 어떻게 돌아가는지에 대해서 이해하게 하는 것이 이 강연에 대한 목표다.

어떻게 돌아가는지에 대해 이해한다면 좋게 사용할 수 있을 것이다.

먼저 iOS 12 용 릴리즈에서 수행했던 몇 가지 작업을 성능과 관련하여 보여줌으로써 시작한다.
우리는 많은 일을 했고, 그것이 우리가 이 강연을 할 수 있는 이유이다.
우리는 내가 말했던 오토레이아웃이 이루어지는 단계별 이해를 구축하기 위해서 노력할 것이다.
그래서 우리는 성과에 대한 좋은 직고나과 좋은 기대를 가지고 있다.
그러기 위해서는 우리는 우리에게 매우 특이한 일을 할 것이다.
그것은 내과가 되는 것이다. 그러니 즐기세요.

(But let's get to it. So first as is traditional for an Apple presentation,)
가장 먼저 애플 프레젠테이션의 전통적인 방식대로 우리는 많은 숫자들을 통해서 자랑할 것이다.
(웃음)
벤치마크를 보여줄 것인데 이 것은 제3자의 애플리케이션뿐만 아니라 여러개의 타사 애플리케이션으로도 살펴본 결과
발생하는 것을 테스트 사례로 분리하여 벤치마킹했다.

이건 셀프사이징을 하는 컬렉션뷰인데 그 옆에거는 iOS 11 이다.
iOS 12는 멋지고 iOS 11 은 나쁘게 보였을 것이다.

iOS 12는 완벽하다. 이건 에시 중 하나일 뿐 다른 샘플이 있다.

(그래프를 보여주며)
보이는 그래프의 회색막대는 iOS 11 이고, 파란색이 iOS 12 이다. 이 그래프는
iOS 11 에서 걸리는 시간을 iOS 12 에서 걸리는 시간과 비교한 것이다.

여러분이 이것을 통해 알 수 있는 것은 우리가 상황을 더 좋게 만들 수 있는 곳을
발견했고 이것은 당신의 어플리케이션들을 향상시킬 것이다.

이것에 대해서는 계속 진행되고 있고, 그 중 일부는 정말 모든 것에 영향을 줄 수 있는 것이기 때문에
그 중 일부는 UI킷으로 옮겨지고 있다. 또 그 중 다른 일부는 사용자가 오토레이아웃에 사용할 수 있게 된다.

**여기서 말하고 싶어하는 건 오토레이아웃이 어떻게 적용되는지 알아야 좀 더 편하고 좋게 사용할 수 있다.**

몇 가지 사례를 들려고 하는데, 클라이언트 코드를 살펴보고 어떤 문제가 있는 살펴볼 것이고
가장 흔히 볼 수 있는 사례들을 선택했다. 이 사례를 겪고 있지 않더라도 이건 모든 사람들에게 새로울 것이다.


이것이 우리가 확인할 사례이고 이걸 만든다고 생각하면 매우 간단하다. 이건 인터페이스 빌더에서 만들 것이다.


마지막에 updateConstraints 를 하는 게 중요한데 하는 이유는 UIView 가 구현될 때 같이 해야하기 때문


### Render Loop
렌더루프란 매초 120회가 실행되면서 보여줘야 하는 것들을 준비하고 보여주는 과정이다.
매초당 120번씩이나 실행되기 때문에 주의가 필요한 과정이다.
그렇기 때문에 관련 된 메소드를 사용하거나 메소드를 오버라이드 할 때는 주의깊게 사용해야한다.

과정은 updateConstraints, Layout, Display 가 나오는데
하위 뷰부터 updateConstraints 가 실행되어 제약조건을 통해 뷰의 위치와 크기를 정하고
정한 것들을 바탕으로 부모 뷰에서 하위뷰로 layoutSubviews 를 통해 하위 뷰들의 레이아웃을 잡는다.
그 다음에는 부모 뷰부터 레이아웃이 잡힌 다음, 
부모 뷰부터 하위 뷰로 draw 를 통해서 뷰들이 화면에 보이기 시작한다.

#### updateConstraints
- updateConstraints

- setNeedsUpdateConstraints (나 업데이트하고 싶으니깐 이따 루프 돌 일 있으면 돌아줘)
- updateConstraintsIfNeeded (나 지금 당장 업데이트 하고 싶어)

#### Layout
- layoutSubviews

- setNeedsLayout (레이아웃 다시 잡아야되니깐 이따 돌 이 있으면 해줘)
- layoutIfNeeded (지금 다시 잡아줘)

### Display
- draw
- setNeedsDisplay

예를 들면, UILabel 이 있고 UILabel 의 크기를 설명하는 제약조건이 있다고 칠 때
해당 크기에 영향을 끼칠 수 있는 값들은 텍스트 속성이 있을 수도 있고 텍스트 크기, 글꼴이 있을 수도 있다.
이를 위한 한 가지 방법은 속성이 하나가 변경될 때마다 텍스트 사이즈를 재측정하는 방법이다.

하지만 이 방법을 사용하면 매우 비효율적이렌데
보통 연속적으로 여러 속성들을 계속 바꾸기 때문에
만약 라벨을 처음 생성할 때 속성을 바꿀 때 마다 재측정되면 낭비되는 것이 있기에
다 끝나고 나서 측정되기를 바랄 것이다.

그것이 바로 Rendor Loop 가 있는 것이고,



which we call churing


performance you got


will look like